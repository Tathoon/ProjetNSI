FlatIcone
Utilisation de la bibliothèque Pygame:

    • Importer la biblio :

Import pygame
from pygame.locals import *

    • Initialiser la biblio :

pygame.init()

    • Créer une fenêtre fonctionnelle de dimmension x,y (qui se ferme lorsque l'on appuie sur la croix):

pygame.init()
fenetre = pygame.display.set_mode((x, y))
Bool=True
while Bool:
	for event in pygame.event.get():
		if event.type == QUIT:
			Bool=False
pygame.quit()

    • Remplir l’arrière plan :

background = pygame.Surface(screen.get_size())	#.get_size() permet de prendre les dimensions de la fenêtre pygame
background = background.convert() qui permet de convertir l'image choisie dans un format plus adapté
background.fill((250, 250, 250)) nécessaire lors du déplacement d'une image en remettant à zero la zone d'affichage

    • Mettre du texte sur l’arrière plan :

font = pygame.font.Font(None, 36)
text = font.render("Hello There", 1, (10, 10, 10))
textpos = text.get_rect()
textpos.centerx = background.get_rect().centerx
background.blit(text, textpos) qui permet de transformer l'arriere plan en changeant la valeur de chaque pixel

    • Rajouter une image (définir l'ap ou en rajouter une dessus) :

fond=pygame.image.load("image.jpg").convert()
fenetre.blit(fond,(0,0))

Rajouter pygame.display.update()  ou pygame.display.flip() à la fin de la boucle for

    • Déplacer une image :

-->Utiliser des objets dits de type Rect (rectangle en 2D)

Définir un objet Rect :

    • les déplacements

entiers :top,left,bottom,right,centerx, centery
tuples:bottomleft,bottomright,topleft,topright,midtop,midleft,midbottom,
midright, center
.move(x,y)
Ex: perso.topleft(x,y)
    • la taille de l'objet

size, width, height – w, h


    • Utiliser les touches pour réaliser des actions :

On doit utiliser K_ devant la touche correspondante 
Type :
pygame.KEYDOWN ou pygame.KEYUP
Ex : if event.key == pygame.K_(touche):
Ex : K_9 ou K_G

NB : Il est également possible de détecter ses touches lorsque que celles-ci sont pressées et le temps de leur pression
--> méthode get_pressed()

	Stocker des infos sur la fenêtre dans des variables

Taille : screen.get_size()
Hauteur : screen.get_height()
Width : screen.get_width()

	Update une fenêtre 

pygame.display.update()
pygame.display.flip()

	Définir les évènements réalisés :

	Détecter les clics de souris :
Type:
pygame.MOUSEBUTTONDOWN ou pygame.MOUSEBUTTONUP
gauche --> if event.button==1:
droite --> if event.button==2:
molette --> if event.button==3:

	Détecter les déplacements de souris :
Type:
pygame.MOUSEMOTION

	Activer de la musique

son = pygame.mixer.Sound("son.wav")
joue=True
	Jouer le son
son.play()

Collisions 

pygame.sprite.spritecollide
#Trouve les sprites étant à l'intersection d'un sprite

pygame.sprite.collide_rect
#detecte collisions entre deux sprites mais utilise un rect

pygame.sprite.collide_rect_ratio
#detecte collisions entre deux sprites mais utilise un rect défini par un ratio

pygame.sprite.collide_circle
#detecte collisions entre deux sprites mais utilise un cercle

pygame.sprite.collide_circle_ratio
#detecte collisions entre deux sprites mais utilise un cercle défini par un ratio

pygame.sprite.collide_mask
#detecte collisions entre deux sprites mais utilise un mask

pygame.sprite.groupcollide
#trouve tous les sprites en collision avec un autre groupe de sprite

pygame.sprite.spritecollideany
#Test vérifiant si un sprite est en collision avec n'importe quoi

	Actions sur le son
pygame.mixer.pause()
pygame.mixer.unpause()

Gérer les fps du jeu :
Clock = pygame.time.clock () #variable stockant l'instance de l'objet clock
Clock.tick(60) # méthode tick() qui initialise les fps du jeu 

Hitbox d'un objet 
objet pygame.Rect
attributs de cet objet : pos x, pos y, largeur, hauteur
